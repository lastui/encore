#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    // Characters
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Comma,
    Dot,
    Semicolon,
    Colon,
    Question,
    Arrow,
    Hash,
    Plus,
    PlusPlus,
    PlusEqual,
    Minus,
    MinusMinus,
    MinusEqual,
    Star,
    StarStar,
    StarEqual,
    StarStarEqual,
    Slash,
    SlashEqual,
    Percent,
    PercentEqual,
    Equal,
    EqualEqual,
    EqualEqualEqual,
    Bang,
    BangEqual,
    BangEqualEqual,
    Greater,
    GreaterEqual,
    GreaterGreater,
    GreaterGreaterEqual,
    GreaterGreaterGreater,
    GreaterGreaterGreaterEqual,
    Less,
    LessEqual,
    LessLess,
    LessLessEqual,
    Ampersand,
    AmpersandEqual,
    AmpersandAmpersand,
    AmpersandAmpersandEqual,
    Pipe,
    PipeEqual,
    PipePipe,
    PipePipeEqual,
    Caret,
    CaretEqual,
    Tilde,
    Ellipsis,
    QuestionQuestion,
    QuestionQuestionEqual,
    QuestionDot,
    // Literals
    Identifier(String),
    StringLiteral(String),
    TemplateLiteral(Vec<TemplatePart>),
    NumberLiteral(f64),
    BigIntLiteral(String),
    RegExpLiteral(String, String),
    True,
    False,
    Null,
    Undefined,
    // Keywords
    Var,
    Let,
    With,
    Const,
    Function,
    Return,
    If,
    Else,
    While,
    For,
    Break,
    Continue,
    This,
    Super,
    New,
    Delete,
    Typeof,
    Void,
    In,
    InstanceOf,
    Try,
    Catch,
    Finally,
    Throw,
    Switch,
    Case,
    Default,
    Await,
    Async,
    Do,
    Enum,
    Of,
    Target,
    Implements,
    Interface,
    Package,
    Private,
    Protected,
    Public,
    Arguments,
    Eval,
    Debugger,
    Class,
    Extends,
    Constructor,
    Static,
    Get,
    Set,
    Yield,
    Import,
    Export,
    From,
    As,
    // Sentinel
    EOS,
}

impl Token {

    pub fn keyword_text(&self) -> Option<&str> {
        match self {
            // Characters/operators don't have keyword text
            Token::LeftParen | Token::RightParen | Token::LeftBrace | 
            Token::RightBrace | Token::LeftBracket | Token::RightBracket | 
            Token::Comma | Token::Dot | Token::Semicolon | Token::Colon | 
            Token::Question | Token::Arrow | Token::Hash | Token::Plus | 
            Token::PlusPlus | Token::PlusEqual | Token::Minus | 
            Token::MinusMinus | Token::MinusEqual | Token::Star | 
            Token::StarStar | Token::StarEqual | Token::StarStarEqual | 
            Token::Slash | Token::SlashEqual | Token::Percent | 
            Token::PercentEqual | Token::Equal | Token::EqualEqual | 
            Token::EqualEqualEqual | Token::Bang | Token::BangEqual | 
            Token::BangEqualEqual | Token::Greater | Token::GreaterEqual | 
            Token::GreaterGreater | Token::GreaterGreaterEqual | 
            Token::GreaterGreaterGreater | Token::GreaterGreaterGreaterEqual | 
            Token::Less | Token::LessEqual | Token::LessLess | 
            Token::LessLessEqual | Token::Ampersand | Token::AmpersandEqual | 
            Token::AmpersandAmpersand | Token::AmpersandAmpersandEqual | 
            Token::Pipe | Token::PipeEqual | Token::PipePipe | 
            Token::PipePipeEqual | Token::Caret | Token::CaretEqual | 
            Token::Tilde | Token::Ellipsis | Token::QuestionQuestion | 
            Token::QuestionQuestionEqual | Token::QuestionDot => None,
            
            // Literals don't have keyword text
            Token::Identifier(_) | Token::StringLiteral(_) | 
            Token::TemplateLiteral(_) | Token::NumberLiteral(_) | 
            Token::BigIntLiteral(_) | Token::RegExpLiteral(_, _) => None,
            
            // Boolean literals and null
            Token::True => Some("true"),
            Token::False => Some("false"),
            Token::Null => Some("null"),
            Token::Undefined => Some("undefined"),
            
            // Keywords
            Token::Var => Some("var"),
            Token::Let => Some("let"),
            Token::With => Some("with"),
            Token::Const => Some("const"),
            Token::Function => Some("function"),
            Token::Return => Some("return"),
            Token::If => Some("if"),
            Token::Else => Some("else"),
            Token::While => Some("while"),
            Token::For => Some("for"),
            Token::Break => Some("break"),
            Token::Continue => Some("continue"),
            Token::This => Some("this"),
            Token::Super => Some("super"),
            Token::New => Some("new"),
            Token::Delete => Some("delete"),
            Token::Typeof => Some("typeof"),
            Token::Void => Some("void"),
            Token::In => Some("in"),
            Token::InstanceOf => Some("instanceof"),
            Token::Try => Some("try"),
            Token::Catch => Some("catch"),
            Token::Finally => Some("finally"),
            Token::Throw => Some("throw"),
            Token::Switch => Some("switch"),
            Token::Case => Some("case"),
            Token::Default => Some("default"),
            Token::Await => Some("await"),
            Token::Async => Some("async"),
            Token::Do => Some("do"),
            Token::Enum => Some("enum"),
            Token::Of => Some("of"),
            Token::Target => Some("target"),
            Token::Implements => Some("implements"),
            Token::Interface => Some("interface"),
            Token::Package => Some("package"),
            Token::Private => Some("private"),
            Token::Protected => Some("protected"),
            Token::Public => Some("public"),
            Token::Arguments => Some("arguments"),
            Token::Eval => Some("eval"),
            Token::Debugger => Some("debugger"),
            Token::Class => Some("class"),
            Token::Extends => Some("extends"),
            Token::Constructor => Some("constructor"),
            Token::Static => Some("static"),
            Token::Get => Some("get"),
            Token::Set => Some("set"),
            Token::Yield => Some("yield"),
            Token::Import => Some("import"),
            Token::Export => Some("export"),
            Token::From => Some("from"),
            Token::As => Some("as"),
            
            // Sentinel
            Token::EOS => None,
        }
    }
    
    pub fn to_string(&self) -> String {
        match self {
            // Literals
            Token::Identifier(name) => name.clone(),
            Token::StringLiteral(s) => format!("\"{}\"", s),
            Token::NumberLiteral(n) => n.to_string(),
            Token::BigIntLiteral(b) => format!("{}n", b),
            Token::RegExpLiteral(pattern, flags) => format!("/{}/{}", pattern, flags),
            Token::TemplateLiteral(_) => "`...`".to_string(),
            
            // Boolean literals and null
            Token::True => "true".to_string(),
            Token::False => "false".to_string(),
            Token::Null => "null".to_string(),
            Token::Undefined => "undefined".to_string(),
            
            // Keywords
            Token::Var => "var".to_string(),
            Token::Let => "let".to_string(),
            Token::With => "with".to_string(),
            Token::Const => "const".to_string(),
            Token::Function => "function".to_string(),
            Token::Return => "return".to_string(),
            Token::If => "if".to_string(),
            Token::Else => "else".to_string(),
            Token::While => "while".to_string(),
            Token::For => "for".to_string(),
            Token::Break => "break".to_string(),
            Token::Continue => "continue".to_string(),
            Token::This => "this".to_string(),
            Token::Super => "super".to_string(),
            Token::New => "new".to_string(),
            Token::Delete => "delete".to_string(),
            Token::Typeof => "typeof".to_string(),
            Token::Void => "void".to_string(),
            Token::In => "in".to_string(),
            Token::InstanceOf => "instanceof".to_string(),
            Token::Try => "try".to_string(),
            Token::Catch => "catch".to_string(),
            Token::Finally => "finally".to_string(),
            Token::Throw => "throw".to_string(),
            Token::Switch => "switch".to_string(),
            Token::Case => "case".to_string(),
            Token::Default => "default".to_string(),
            Token::Await => "await".to_string(),
            Token::Async => "async".to_string(),
            Token::Do => "do".to_string(),
            Token::Enum => "enum".to_string(),
            Token::Of => "of".to_string(),
            Token::Target => "target".to_string(),
            Token::Implements => "implements".to_string(),
            Token::Interface => "interface".to_string(),
            Token::Package => "package".to_string(),
            Token::Private => "private".to_string(),
            Token::Protected => "protected".to_string(),
            Token::Public => "public".to_string(),
            Token::Arguments => "arguments".to_string(),
            Token::Eval => "eval".to_string(),
            Token::Debugger => "debugger".to_string(),
            Token::Class => "class".to_string(),
            Token::Extends => "extends".to_string(),
            Token::Constructor => "constructor".to_string(),
            Token::Static => "static".to_string(),
            Token::Get => "get".to_string(),
            Token::Set => "set".to_string(),
            Token::Yield => "yield".to_string(),
            Token::Import => "import".to_string(),
            Token::Export => "export".to_string(),
            Token::From => "from".to_string(),
            Token::As => "as".to_string(),
            
            // Characters and operators
            Token::LeftParen => "(".to_string(),
            Token::RightParen => ")".to_string(),
            Token::LeftBrace => "{".to_string(),
            Token::RightBrace => "}".to_string(),
            Token::LeftBracket => "[".to_string(),
            Token::RightBracket => "]".to_string(),
            Token::Comma => ",".to_string(),
            Token::Dot => ".".to_string(),
            Token::Semicolon => ";".to_string(),
            Token::Colon => ":".to_string(),
            Token::Question => "?".to_string(),
            Token::Arrow => "=>".to_string(),
            Token::Hash => "#".to_string(),
            Token::Plus => "+".to_string(),
            Token::PlusPlus => "++".to_string(),
            Token::PlusEqual => "+=".to_string(),
            Token::Minus => "-".to_string(),
            Token::MinusMinus => "--".to_string(),
            Token::MinusEqual => "-=".to_string(),
            Token::Star => "*".to_string(),
            Token::StarStar => "**".to_string(),
            Token::StarEqual => "*=".to_string(),
            Token::StarStarEqual => "**=".to_string(),
            Token::Slash => "/".to_string(),
            Token::SlashEqual => "/=".to_string(),
            Token::Percent => "%".to_string(),
            Token::PercentEqual => "%=".to_string(),
            Token::Equal => "=".to_string(),
            Token::EqualEqual => "==".to_string(),
            Token::EqualEqualEqual => "===".to_string(),
            Token::Bang => "!".to_string(),
            Token::BangEqual => "!=".to_string(),
            Token::BangEqualEqual => "!==".to_string(),
            Token::Greater => ">".to_string(),
            Token::GreaterEqual => ">=".to_string(),
            Token::GreaterGreater => ">>".to_string(),
            Token::GreaterGreaterEqual => ">>=".to_string(),
            Token::GreaterGreaterGreater => ">>>".to_string(),
            Token::GreaterGreaterGreaterEqual => ">>>=".to_string(),
            Token::Less => "<".to_string(),
            Token::LessEqual => "<=".to_string(),
            Token::LessLess => "<<".to_string(),
            Token::LessLessEqual => "<<=".to_string(),
            Token::Ampersand => "&".to_string(),
            Token::AmpersandEqual => "&=".to_string(),
            Token::AmpersandAmpersand => "&&".to_string(),
            Token::AmpersandAmpersandEqual => "&&=".to_string(),
            Token::Pipe => "|".to_string(),
            Token::PipeEqual => "|=".to_string(),
            Token::PipePipe => "||".to_string(),
            Token::PipePipeEqual => "||=".to_string(),
            Token::Caret => "^".to_string(),
            Token::CaretEqual => "^=".to_string(),
            Token::Tilde => "~".to_string(),
            Token::Ellipsis => "...".to_string(),
            Token::QuestionQuestion => "??".to_string(),
            Token::QuestionQuestionEqual => "??=".to_string(),
            Token::QuestionDot => "?.".to_string(),
            
            // Sentinel
            Token::EOS => "<end>".to_string(),
        }
    }

}

#[derive(Debug, Clone, PartialEq)]
pub enum TemplatePart {
    String(String),
    Expression(String),
}
